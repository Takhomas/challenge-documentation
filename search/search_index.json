{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Deadlock Challenges Overview This documentation is mainly used to help everyone with the creation of their own learning content, through Deadlock platform. What is a challenge ? A challenge is mainly these elements: A documentation: instructions for the user A template folder: code provided to the user A success folder: solution of the challenge An app folder: logic to verify user code The challenge descriptor: challenge.yml Many hints: You can add different hints, each one could be unlock with token, user unlock You can discover many elements on the user interface: Documentation with briefing (main informations), hints Provided code Run button is used to executed code without any test Submit buttin is used to executed test on user code Getting Started Each challenge came with a special structure, it will be provided by our tool DCLI So it's pretty easy to start any challenge, you will just have to care what you want to deliver to your users. Install DCLI Install dcli package using pip: pip install dcli Then you shoud have dcli command on your system. Run dcli --help to check that everything worked well. $ dcli --help man page should be printed Create your first code challenge Let's create a Java mission to explain you the concept behind the structure. dcli gen java We will generate a simple challenge where the user must return Hello World! . You can explore the generated code_hello_world directory: code_hello_world/ \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 briefing.md \u2502 \u2514\u2500\u2500 fr \u2502 \u2514\u2500\u2500 briefing.md \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2502 \u2514\u2500\u2500 Test.java \u2502 \u251c\u2500\u2500 success \u2502 \u2502 \u2514\u2500\u2500 HelloWorld.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 HelloWorld.java \u251c\u2500\u2500 challenge.yml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u2514\u2500\u2500 thumbnail.png As you saw it, the goal is simple, implement the sayHello() method within template package. All files under template package will be served to the user, you can create as much as you want. The HelloWorld.java file under success package will be served only when the user succeed the challenge. You have to complete all //TODO present in the code. Let's start with src/main/java/success/HelloWorld.java , this is the solution file. public static String sayHello() { //TODO write your own solution return null; } Pretty simple the method has to return \"Hello World!\" . Next part is to compare the user result with the expected result, this part is done under src/main/java/app/Solve.java . Dcli generates some part of code for you but have to complete with your own logic. public static void main(String[] args) { try { // user result String userResult = HelloWorld.sayHello(); // your solution result String expectedResult = success.HelloWorld.sayHello(); //TODO you have to do different tests to be sure user has the good solution. // comparing userResult and expectedResult if (expectedResult.equals(userResult)) { // if all test passed successfully Logger.logSuccess(); } else { Logger.logFail(expectedResult, userResult); System.exit(1); } } catch (RuntimeException e) { Logger.logException(e); // if something bad happened exit with error code System.exit(1); } } What it does is that if the function HelloWorld.sayHello() does not return \"Hello World!\" or throws an exception, it logs an error and exits with an error code. In general, there are 2 kinds of outputs you have to take into account. Error: The code sent does not compile, does not have the right signature, code did not return the expected result, something bad happened. Success: The code did complete normally and returned the expected result A simple Logger class is also generated. You can now test your challenge with the following command lines: cd ./code_hello_world dcli run . # Run the program, execute the file `src/main/java/app/Test.java` dcli solve . # Run the program with your tests, execute the file `src/main/java/app/Solve.java` You can try to modify the HelloWorld.java file under template package to reach the solution like you were the candidate. Documentation The documentation is stored in code_hello_world/docs/ . It contains the Briefing to expose the problem your candidate has to solve and motivate him. It should be written in Markdown, it supports HTML tags and LateX language. briefing.md: contains the default instructions debriefing.md: contains a text provided when user solve the challenge hint1.md: first hint user can unlock (optional) hint2.md: an other hint (optional) examples of hints: hint1.md The String that you need to return is the two words that you usually display when you start learning a language for instance. It can be considered as a greeting. (PS: the word is not \"It Works\") hint2.md Alright, the String is case sensitive, so you might want to try multiple cases. Also, we were very emotional when we wrote this challenge, and decided to end the phrase with a \"!\" N.B.: hint2 will always be given after hint1. At this point, we have a functional Java application that will test the content of a compiled HelloWorld.class class and exit the relevant code. If you want to understand more how the challenge works and custom more your challenge you can read this . i18n The default files into the docs folder contains the english translations. If you want handle other languages you have to create new directories following this way: docs briefing.md fr briefing.md and so on. What's next You can explore different types of challenge: Hack Multi Service SQL","title":"Home"},{"location":"#deadlock-challenges","text":"","title":"Deadlock Challenges"},{"location":"#overview","text":"This documentation is mainly used to help everyone with the creation of their own learning content, through Deadlock platform.","title":"Overview"},{"location":"#what-is-a-challenge","text":"A challenge is mainly these elements: A documentation: instructions for the user A template folder: code provided to the user A success folder: solution of the challenge An app folder: logic to verify user code The challenge descriptor: challenge.yml Many hints: You can add different hints, each one could be unlock with token, user unlock You can discover many elements on the user interface: Documentation with briefing (main informations), hints Provided code Run button is used to executed code without any test Submit buttin is used to executed test on user code","title":"What is a challenge ?"},{"location":"#getting-started","text":"Each challenge came with a special structure, it will be provided by our tool DCLI So it's pretty easy to start any challenge, you will just have to care what you want to deliver to your users.","title":"Getting Started"},{"location":"#install-dcli","text":"Install dcli package using pip: pip install dcli Then you shoud have dcli command on your system. Run dcli --help to check that everything worked well. $ dcli --help man page should be printed","title":"Install DCLI"},{"location":"#create-your-first-code-challenge","text":"Let's create a Java mission to explain you the concept behind the structure. dcli gen java We will generate a simple challenge where the user must return Hello World! . You can explore the generated code_hello_world directory: code_hello_world/ \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 briefing.md \u2502 \u2514\u2500\u2500 fr \u2502 \u2514\u2500\u2500 briefing.md \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u251c\u2500\u2500 app \u2502 \u2502 \u251c\u2500\u2500 Logger.java \u2502 \u2502 \u251c\u2500\u2500 Solve.java \u2502 \u2502 \u2514\u2500\u2500 Test.java \u2502 \u251c\u2500\u2500 success \u2502 \u2502 \u2514\u2500\u2500 HelloWorld.java \u2502 \u2514\u2500\u2500 template \u2502 \u2514\u2500\u2500 HelloWorld.java \u251c\u2500\u2500 challenge.yml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 run.sh \u2514\u2500\u2500 thumbnail.png As you saw it, the goal is simple, implement the sayHello() method within template package. All files under template package will be served to the user, you can create as much as you want. The HelloWorld.java file under success package will be served only when the user succeed the challenge. You have to complete all //TODO present in the code. Let's start with src/main/java/success/HelloWorld.java , this is the solution file. public static String sayHello() { //TODO write your own solution return null; } Pretty simple the method has to return \"Hello World!\" . Next part is to compare the user result with the expected result, this part is done under src/main/java/app/Solve.java . Dcli generates some part of code for you but have to complete with your own logic. public static void main(String[] args) { try { // user result String userResult = HelloWorld.sayHello(); // your solution result String expectedResult = success.HelloWorld.sayHello(); //TODO you have to do different tests to be sure user has the good solution. // comparing userResult and expectedResult if (expectedResult.equals(userResult)) { // if all test passed successfully Logger.logSuccess(); } else { Logger.logFail(expectedResult, userResult); System.exit(1); } } catch (RuntimeException e) { Logger.logException(e); // if something bad happened exit with error code System.exit(1); } } What it does is that if the function HelloWorld.sayHello() does not return \"Hello World!\" or throws an exception, it logs an error and exits with an error code. In general, there are 2 kinds of outputs you have to take into account. Error: The code sent does not compile, does not have the right signature, code did not return the expected result, something bad happened. Success: The code did complete normally and returned the expected result A simple Logger class is also generated. You can now test your challenge with the following command lines: cd ./code_hello_world dcli run . # Run the program, execute the file `src/main/java/app/Test.java` dcli solve . # Run the program with your tests, execute the file `src/main/java/app/Solve.java` You can try to modify the HelloWorld.java file under template package to reach the solution like you were the candidate.","title":"Create your first code challenge"},{"location":"#documentation","text":"The documentation is stored in code_hello_world/docs/ . It contains the Briefing to expose the problem your candidate has to solve and motivate him. It should be written in Markdown, it supports HTML tags and LateX language. briefing.md: contains the default instructions debriefing.md: contains a text provided when user solve the challenge hint1.md: first hint user can unlock (optional) hint2.md: an other hint (optional) examples of hints: hint1.md The String that you need to return is the two words that you usually display when you start learning a language for instance. It can be considered as a greeting. (PS: the word is not \"It Works\") hint2.md Alright, the String is case sensitive, so you might want to try multiple cases. Also, we were very emotional when we wrote this challenge, and decided to end the phrase with a \"!\" N.B.: hint2 will always be given after hint1. At this point, we have a functional Java application that will test the content of a compiled HelloWorld.class class and exit the relevant code. If you want to understand more how the challenge works and custom more your challenge you can read this .","title":"Documentation"},{"location":"#i18n","text":"The default files into the docs folder contains the english translations. If you want handle other languages you have to create new directories following this way: docs briefing.md fr briefing.md and so on.","title":"i18n"},{"location":"#whats-next","text":"You can explore different types of challenge: Hack Multi Service SQL","title":"What's next"},{"location":"about/","text":"Longum miseranda quam ad caelo digitis Iras iuvenalibus quam ancipiti colunt pariter propago Lorem markdownum animalia propago praecordia Iuppiter nec nequit umeris medullis: si locus . Labori edere ille pullo repperit! Antandro protinus flores, si alvum , suas inque videor. Deam patria iamque, soror quod membris vero, per non concurrere. Fecit hiatu Rubent illum utere adspergine fingit curru Accedere ira summaque famem Ante nomine iubet rugis factaque peregrinum nomina Relictas signis Mensura favorque conscia columbae divitias Hoc limen nomine mala: per et adspergit divum filis! Petendi conscendit adversos tu perque Marte missa viderat quaeque flagellis conceditur rettulit , admoneo ageret quo si Schoeneia mota, est. Rigent avara aduncos tuque . Cum uno inerti conligit Achillea Potiorque passu ambo triste cinis et auro brevissimus exitus taurus. Illo dant solita amore dare; Iove mirantis species genitor celebrant solacia traxere ortus . Relapsa aut viridi ferarum alto . Orba nobilium fertur. Triplicis distante Cepheus Bene mutata quam, licet rapit pater cadat; quibus litus habuit ripis me, temptat. Cum sonum parias hinc incipit nusquam ubi amamus aestuque nescit aeternum prior perdiderat iuventam semina. Modo viscera certa redit Athin suo stipite aliter est eurus ut quisque paratis, pictis, tam septem. Graviore puer telum inque, inguina hinc. Fatidicus ambit: prius mutavit , nixus parte arma sanguine pes quia coepta ducentem, promissas. Timori fugat perisset istas , quo, pronis! Huc pectore umeri! Rauca alis et retinacula oculos, suam, habet moenia venit potest, unda. Celsis plangore de murmure nactasque Materiem famulas, utque mihi, inferius culpavit colebat; amplexas insignia, requiemque. Venerantur metallis incubuit in laborum absit linguae terga, siccatque et ostendit, quae. Palladios quod lapides fecunda dedit mulcendaque nempe Mavortius turribus mille! Sedes praesepia truces ut horruit ingens pretium tempus stratis agitasse Talibus parentum ait clamantia coniuge contemptaque signa felix. Extis Erectheus est, non sed, ater Berecyntia concubiturus terret hunc gemit: est parvae nec Pergama! In populi tam Eurydicenque naribus cetera. A oderat ignaram pontus haesit adfusaeque et pello vertuntur umbra: intonat. Pluvio pedesque omnia: noxia Phoebi exsecratur Hylaeusque conscius Cumarum.","title":"About"},{"location":"about/#longum-miseranda-quam-ad-caelo-digitis","text":"","title":"Longum miseranda quam ad caelo digitis"},{"location":"about/#iras-iuvenalibus-quam-ancipiti-colunt-pariter-propago","text":"Lorem markdownum animalia propago praecordia Iuppiter nec nequit umeris medullis: si locus . Labori edere ille pullo repperit! Antandro protinus flores, si alvum , suas inque videor. Deam patria iamque, soror quod membris vero, per non concurrere. Fecit hiatu Rubent illum utere adspergine fingit curru Accedere ira summaque famem Ante nomine iubet rugis factaque peregrinum nomina Relictas signis","title":"Iras iuvenalibus quam ancipiti colunt pariter propago"},{"location":"about/#mensura-favorque-conscia-columbae-divitias","text":"Hoc limen nomine mala: per et adspergit divum filis! Petendi conscendit adversos tu perque Marte missa viderat quaeque flagellis conceditur rettulit , admoneo ageret quo si Schoeneia mota, est. Rigent avara aduncos tuque .","title":"Mensura favorque conscia columbae divitias"},{"location":"about/#cum-uno-inerti-conligit-achillea","text":"Potiorque passu ambo triste cinis et auro brevissimus exitus taurus. Illo dant solita amore dare; Iove mirantis species genitor celebrant solacia traxere ortus . Relapsa aut viridi ferarum alto . Orba nobilium fertur.","title":"Cum uno inerti conligit Achillea"},{"location":"about/#triplicis-distante-cepheus","text":"Bene mutata quam, licet rapit pater cadat; quibus litus habuit ripis me, temptat. Cum sonum parias hinc incipit nusquam ubi amamus aestuque nescit aeternum prior perdiderat iuventam semina. Modo viscera certa redit Athin suo stipite aliter est eurus ut quisque paratis, pictis, tam septem. Graviore puer telum inque, inguina hinc. Fatidicus ambit: prius mutavit , nixus parte arma sanguine pes quia coepta ducentem, promissas. Timori fugat perisset istas , quo, pronis! Huc pectore umeri! Rauca alis et retinacula oculos, suam, habet moenia venit potest, unda.","title":"Triplicis distante Cepheus"},{"location":"about/#celsis-plangore-de-murmure-nactasque","text":"Materiem famulas, utque mihi, inferius culpavit colebat; amplexas insignia, requiemque. Venerantur metallis incubuit in laborum absit linguae terga, siccatque et ostendit, quae. Palladios quod lapides fecunda dedit mulcendaque nempe Mavortius turribus mille! Sedes praesepia truces ut horruit ingens pretium tempus stratis agitasse Talibus parentum ait clamantia coniuge contemptaque signa felix. Extis Erectheus est, non sed, ater Berecyntia concubiturus terret hunc gemit: est parvae nec Pergama! In populi tam Eurydicenque naribus cetera. A oderat ignaram pontus haesit adfusaeque et pello vertuntur umbra: intonat. Pluvio pedesque omnia: noxia Phoebi exsecratur Hylaeusque conscius Cumarum.","title":"Celsis plangore de murmure nactasque"},{"location":"how-does-it-work/","text":"How does it work ? If you are here, you already read the Getting Started and you want to explore more about how a challenge works. We are going to explain you different files, To be sure to understand the next parts you have to be familiar with: Docker Yaml Dockerfile When your candidate submits his code, a Docker container will be created. The name of the Docker image will be your challenge name, prefixed with code_ . Important: your container should have its own CMD or ENTRYPOINT defined. Before your container is executed, your candidate code will be pasted within template folder. Where and what this file is is entirely up to you and shall be submitted in the descriptor . Once the code is inside the container, your container will be ran until completion. Note that the STDOUT and STDERR signals will be streamed to the candidate. Once it completes, the exit code will be checked. If the exit code is 0 , the challenge was completed successfully. Otherwise , it means the candidate has failed . You can custom the Dockerfile has you wish, include external library to allow your user to have new experiences ! Example of a python challenge with nymphy, sklearn and pandas libraries : FROM python:3.7-slim RUN pip install numpy sklearn pandas WORKDIR / COPY src src COPY wine.csv src/main/ COPY run.sh / RUN chmod +x run.sh ENTRYPOINT [\"/run.sh\"] The build step is done only one time when your challenge is accepeted by the Deadlock team. Challenge descriptor Each challenge has its own challenge descriptor in challengename/challenge.yaml. It is used to create the challenge container and retrieve your specifications regarding the language and file target. name: code_halloween_candy # your challenge name. MUST be equal to the challenge folder label: Halloween Candy # your challenge label description: Help your brother split his halloween candy # your challenge description, in english level: jarjarbinks # your challenge level. From easiest to hardest: jarjarbinks, ewok, padawan, jedi, master type: CODING # this is a coding game xp: # the experience it should bring. any label is supported programming: 1 # this is a weight, not a number java: 1 coding: # coding game specifics templateDirectory: src/java/main/template # code provided to the user successDirectory: src/java/main/success # solution of the challenge target: CandySplitter.java # the target file path, consider as Main file editorMode: java # the language to be displayed by the web editor","title":"How does it work ?"},{"location":"how-does-it-work/#how-does-it-work","text":"If you are here, you already read the Getting Started and you want to explore more about how a challenge works. We are going to explain you different files, To be sure to understand the next parts you have to be familiar with: Docker Yaml","title":"How does it work ?"},{"location":"how-does-it-work/#dockerfile","text":"When your candidate submits his code, a Docker container will be created. The name of the Docker image will be your challenge name, prefixed with code_ . Important: your container should have its own CMD or ENTRYPOINT defined. Before your container is executed, your candidate code will be pasted within template folder. Where and what this file is is entirely up to you and shall be submitted in the descriptor . Once the code is inside the container, your container will be ran until completion. Note that the STDOUT and STDERR signals will be streamed to the candidate. Once it completes, the exit code will be checked. If the exit code is 0 , the challenge was completed successfully. Otherwise , it means the candidate has failed . You can custom the Dockerfile has you wish, include external library to allow your user to have new experiences ! Example of a python challenge with nymphy, sklearn and pandas libraries : FROM python:3.7-slim RUN pip install numpy sklearn pandas WORKDIR / COPY src src COPY wine.csv src/main/ COPY run.sh / RUN chmod +x run.sh ENTRYPOINT [\"/run.sh\"] The build step is done only one time when your challenge is accepeted by the Deadlock team.","title":"Dockerfile"},{"location":"how-does-it-work/#challenge-descriptor","text":"Each challenge has its own challenge descriptor in challengename/challenge.yaml. It is used to create the challenge container and retrieve your specifications regarding the language and file target. name: code_halloween_candy # your challenge name. MUST be equal to the challenge folder label: Halloween Candy # your challenge label description: Help your brother split his halloween candy # your challenge description, in english level: jarjarbinks # your challenge level. From easiest to hardest: jarjarbinks, ewok, padawan, jedi, master type: CODING # this is a coding game xp: # the experience it should bring. any label is supported programming: 1 # this is a weight, not a number java: 1 coding: # coding game specifics templateDirectory: src/java/main/template # code provided to the user successDirectory: src/java/main/success # solution of the challenge target: CandySplitter.java # the target file path, consider as Main file editorMode: java # the language to be displayed by the web editor","title":"Challenge descriptor"},{"location":"challenge-types/code/","text":"","title":"Code"},{"location":"challenge-types/hack/","text":"//TODO","title":"Hack"},{"location":"challenge-types/multi-service/","text":"Multi-service challenges Sometimes, you may have to declare multiple services in your challenge. This feature is fully supported and uses containers within one network. Here is a walkthrough of adding another service named db . In the main folder of your challenge, create the directories code_your_mission/services/db . This directory will contain your service files. In this folder, you must declare at least two files: * The service descriptor service.yaml * The service container Dockerfile The service descriptor The service descriptor can expose ports and a specific alias (which must be the service name). Following on our example, the db service would be: name: db exposed_ports: - 5432 You can find an example of a multi services challenge though SQL type challenge .","title":"Multi service"},{"location":"challenge-types/multi-service/#multi-service-challenges","text":"Sometimes, you may have to declare multiple services in your challenge. This feature is fully supported and uses containers within one network. Here is a walkthrough of adding another service named db . In the main folder of your challenge, create the directories code_your_mission/services/db . This directory will contain your service files. In this folder, you must declare at least two files: * The service descriptor service.yaml * The service container Dockerfile","title":"Multi-service challenges"},{"location":"challenge-types/multi-service/#the-service-descriptor","text":"The service descriptor can expose ports and a specific alias (which must be the service name). Following on our example, the db service would be: name: db exposed_ports: - 5432 You can find an example of a multi services challenge though SQL type challenge .","title":"The service descriptor"},{"location":"challenge-types/sql/","text":"SQL Challenges There is two main kinds of SQL challenges: Read-only challenges For example your answer is something like SELECT * FROM public.\"myTable\" ... In this case, you need to * Run the expected answer and store answer first ! * Run the given answer and store answer only after ! * Compare both answer You need to run your order first to avoid rollback the database in case of the user modifies it Read-write challenges This kind of challenge is a little bit more complicated to validate. They mainly start with DELETE/UPDATE/ALTER TABLE ... In this case, you need to write a checker.sql (usually with a SELECT request) file in addition to success/query.sql. The success/query.sql will modifies the database (like the expected answer) and the checker.sql will select all interesting rows in the database Run the expected answer Run the checker.sql script and store the answer Rollback the database Run the given answer Run the checker.sql script and store the answer Compare both answer Tree example of SQL challenge \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 DBComparator.java \u2502 \u2502 \u251c\u2500\u2500 QueryResult.java \u2502 \u2502 \u2514\u2500\u2500 ScriptRunner.java \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 db.properties \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 checker.sql \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 services \u2502 \u2514\u2500\u2500 db \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 entries \u2502 \u2502 \u251c\u2500\u2500 1-schema.sql \u2502 \u2502 \u251c\u2500\u2500 2_1-data-person.sql \u2502 \u2502 \u251c\u2500\u2500 2_2-data-crime.sql \u2502 \u2502 \u2514\u2500\u2500 2_3-data-crime_person.sql \u2502 \u251c\u2500\u2500 init-and-dump.Dockerfile \u2502 \u251c\u2500\u2500 initiator \u2502 \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2502 \u2514\u2500\u2500 src \u2502 \u2502 \u2514\u2500\u2500 main \u2502 \u2502 \u2514\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 Crime.java \u2502 \u2502 \u251c\u2500\u2500 CriminalRecord.java \u2502 \u2502 \u2514\u2500\u2500 User.java \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 run-dump.sh \u2502 \u251c\u2500\u2500 service.yaml \u2502 \u2514\u2500\u2500 wait-for-it.sh \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 query.sql \u251c\u2500\u2500 template \u2502 \u2514\u2500\u2500 query.sql \u2514\u2500\u2500 thumbnail.png","title":"SQL"},{"location":"challenge-types/sql/#sql-challenges","text":"There is two main kinds of SQL challenges:","title":"SQL Challenges"},{"location":"challenge-types/sql/#read-only-challenges","text":"For example your answer is something like SELECT * FROM public.\"myTable\" ... In this case, you need to * Run the expected answer and store answer first ! * Run the given answer and store answer only after ! * Compare both answer You need to run your order first to avoid rollback the database in case of the user modifies it","title":"Read-only challenges"},{"location":"challenge-types/sql/#read-write-challenges","text":"This kind of challenge is a little bit more complicated to validate. They mainly start with DELETE/UPDATE/ALTER TABLE ... In this case, you need to write a checker.sql (usually with a SELECT request) file in addition to success/query.sql. The success/query.sql will modifies the database (like the expected answer) and the checker.sql will select all interesting rows in the database Run the expected answer Run the checker.sql script and store the answer Rollback the database Run the given answer Run the checker.sql script and store the answer Compare both answer","title":"Read-write challenges"},{"location":"challenge-types/sql/#tree-example-of-sql-challenge","text":"\u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 DBComparator.java \u2502 \u2502 \u251c\u2500\u2500 QueryResult.java \u2502 \u2502 \u2514\u2500\u2500 ScriptRunner.java \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 db.properties \u251c\u2500\u2500 challenge.yaml \u251c\u2500\u2500 checker.sql \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 run.sh \u251c\u2500\u2500 services \u2502 \u2514\u2500\u2500 db \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 entries \u2502 \u2502 \u251c\u2500\u2500 1-schema.sql \u2502 \u2502 \u251c\u2500\u2500 2_1-data-person.sql \u2502 \u2502 \u251c\u2500\u2500 2_2-data-crime.sql \u2502 \u2502 \u2514\u2500\u2500 2_3-data-crime_person.sql \u2502 \u251c\u2500\u2500 init-and-dump.Dockerfile \u2502 \u251c\u2500\u2500 initiator \u2502 \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2502 \u2514\u2500\u2500 src \u2502 \u2502 \u2514\u2500\u2500 main \u2502 \u2502 \u2514\u2500\u2500 java \u2502 \u2502 \u251c\u2500\u2500 Core.java \u2502 \u2502 \u251c\u2500\u2500 Crime.java \u2502 \u2502 \u251c\u2500\u2500 CriminalRecord.java \u2502 \u2502 \u2514\u2500\u2500 User.java \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 run-dump.sh \u2502 \u251c\u2500\u2500 service.yaml \u2502 \u2514\u2500\u2500 wait-for-it.sh \u251c\u2500\u2500 success \u2502 \u2514\u2500\u2500 query.sql \u251c\u2500\u2500 template \u2502 \u2514\u2500\u2500 query.sql \u2514\u2500\u2500 thumbnail.png","title":"Tree example of SQL challenge"},{"location":"mode/","text":"Sandbox There is also an other mission mode, sandbox one. Common mission must contains a list of test to allow the user to succeed the mission. But sometimes it can be painful or impossible to implement test to make sure the user understood and succeed well the challenge. So you can also create a mission without any test but you still have to create the Test class. The professor will be able to validate the mission via the student page. The only thing to add is sandboxed: true to the challenge.yaml file. Example: name: code_interview_card_game label: Card Game description: Card Game level: ewok type: CODING sandboxed: true Blacklist words By default there are some words the user cannot use into his code. You can find example into resources/default/blacklist . You can also create your own blacklist for your challenge by creating a blacklist file next to the challenge.yaml, then fill it as a csv file. It also supports regex expressions. Example of blacklist file: [^<>](<|>)[^><],(System\\.exit\\()(\\d)*(\\)),(Runtime\\.getRuntime\\(\\)\\.exit\\(\\d*\\))","title":"Mode"},{"location":"mode/#sandbox","text":"There is also an other mission mode, sandbox one. Common mission must contains a list of test to allow the user to succeed the mission. But sometimes it can be painful or impossible to implement test to make sure the user understood and succeed well the challenge. So you can also create a mission without any test but you still have to create the Test class. The professor will be able to validate the mission via the student page. The only thing to add is sandboxed: true to the challenge.yaml file. Example: name: code_interview_card_game label: Card Game description: Card Game level: ewok type: CODING sandboxed: true","title":"Sandbox"},{"location":"mode/#blacklist-words","text":"By default there are some words the user cannot use into his code. You can find example into resources/default/blacklist . You can also create your own blacklist for your challenge by creating a blacklist file next to the challenge.yaml, then fill it as a csv file. It also supports regex expressions. Example of blacklist file: [^<>](<|>)[^><],(System\\.exit\\()(\\d)*(\\)),(Runtime\\.getRuntime\\(\\)\\.exit\\(\\d*\\))","title":"Blacklist words"}]}